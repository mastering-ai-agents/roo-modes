<specification_first_best_practices>
  <overview>
    Best practices for Specification-First Development that ensure high-quality,
    maintainable software through systematic planning and context engineering.
  </overview>

  <core_principles>
    <principle priority="critical">
      <name>Specifications as Source of Truth</name>
      <description>
        All specifications must be comprehensive, current, and serve as the definitive
        source of truth for system behavior and implementation.
      </description>
      <rationale>
        When specifications are incomplete or outdated, AI-generated code becomes
        inconsistent and team collaboration breaks down.
      </rationale>
      <implementation>
        <practice>Update specifications before making any code changes</practice>
        <practice>Validate all implementations against current specifications</practice>
        <practice>Use specifications as the primary communication medium</practice>
        <practice>Treat specification updates as formal change management</practice>
      </implementation>
    </principle>

    <principle priority="critical">
      <name>Context Engineering First</name>
      <description>
        Design specifications to provide complete context for AI consumption,
        minimizing the need for additional explanation or interaction.
      </description>
      <rationale>
        Well-engineered context enables AI to generate production-ready code
        with minimal human oversight, dramatically improving efficiency.
      </rationale>
      <implementation>
        <practice>Include system, business, and technical context in all specifications</practice>
        <practice>Use reference patterns to establish context inheritance</practice>
        <practice>Design specifications for AI consumption, not just human reading</practice>
        <practice>Test specifications by using them for AI-generated implementations</practice>
      </implementation>
    </principle>

    <principle priority="high">
      <name>Progressive Specification Development</name>
      <description>
        Develop specifications in logical order: system overview, shared components,
        features, then infrastructure.
      </description>
      <rationale>
        This order ensures that foundational decisions inform detailed specifications,
        preventing inconsistencies and rework.
      </rationale>
      <implementation>
        <practice>Complete system overview before any feature specifications</practice>
        <practice>Define shared patterns before feature-specific implementations</practice>
        <practice>Use established patterns consistently across features</practice>
        <practice>Plan infrastructure requirements based on feature needs</practice>
      </implementation>
    </principle>

    <principle priority="high">
      <name>Systematic Quality Assurance</name>
      <description>
        Implement systematic validation processes to ensure all outputs meet
        production standards and specification compliance.
      </description>
      <rationale>
        Without systematic validation, specification-first development can produce
        technically correct but practically unusable implementations.
      </rationale>
      <implementation>
        <practice>Validate every implementation against its specifications</practice>
        <practice>Check integration points between components</practice>
        <practice>Verify business logic matches specification intent</practice>
        <practice>Ensure UI implementations meet design requirements</practice>
      </implementation>
    </principle>
  </core_principles>

  <specification_writing_guidelines>
    <category name="completeness">
      <guideline priority="critical">
        <rule>Every specification must provide complete context</rule>
        <rationale>Incomplete context leads to AI making incorrect assumptions</rationale>
        <checklist>
          <item>System context is clearly established</item>
          <item>Business context explains the "why" behind requirements</item>
          <item>Technical context defines implementation constraints</item>
          <item>Integration points are explicitly documented</item>
          <item>Dependencies on other specifications are referenced</item>
        </checklist>
      </guideline>

      <guideline priority="high">
        <rule>Include examples and edge cases in specifications</rule>
        <rationale>Examples clarify intent and edge cases prevent production issues</rationale>
        <checklist>
          <item>Provide concrete examples for abstract requirements</item>
          <item>Document expected behavior for edge cases</item>
          <item>Include error handling scenarios</item>
          <item>Show integration patterns with examples</item>
        </checklist>
      </guideline>
    </category>

    <category name="consistency">
      <guideline priority="critical">
        <rule>Use consistent terminology across all specifications</rule>
        <rationale>Inconsistent terminology confuses AI and leads to implementation errors</rationale>
        <implementation>
          <practice>Maintain a project glossary of terms</practice>
          <practice>Use the same names for concepts across specifications</practice>
          <practice>Reference shared definitions rather than redefining</practice>
          <practice>Validate terminology consistency during reviews</practice>
        </implementation>
      </guideline>

      <guideline priority="high">
        <rule>Follow established patterns and templates</rule>
        <rationale>Consistent structure helps AI parse and understand specifications</rationale>
        <implementation>
          <practice>Use the six-type specification framework consistently</practice>
          <practice>Follow template structures for each specification type</practice>
          <practice>Maintain consistent section organization</practice>
          <practice>Use standard formats for common elements</practice>
        </implementation>
      </guideline>
    </category>

    <category name="maintainability">
      <guideline priority="high">
        <rule>Design specifications for long-term maintenance</rule>
        <rationale>Specifications must evolve with the system over time</rationale>
        <implementation>
          <practice>Use modular specification structure</practice>
          <practice>Separate stable concepts from volatile details</practice>
          <practice>Document specification dependencies clearly</practice>
          <practice>Plan for specification versioning</practice>
        </implementation>
      </guideline>

      <guideline priority="medium">
        <rule>Include rationale for major decisions</rule>
        <rationale>Future maintainers need to understand why decisions were made</rationale>
        <implementation>
          <practice>Document architectural decision rationale</practice>
          <practice>Explain technology choices and trade-offs</practice>
          <practice>Record business context for requirements</practice>
          <practice>Note alternatives considered and rejected</practice>
        </implementation>
      </guideline>
    </category>
  </specification_writing_guidelines>

  <context_engineering_practices>
    <practice name="reference_heavy_communication">
      <description>Minimize explanation by maximizing specification references</description>
      <technique>
        Instead of explaining requirements in prompts, reference the specifications
        that contain complete context and requirements.
      </technique>
      <example>
        <bad>
          "Create a user authentication system with JWT tokens, password validation,
          and social login support that integrates with our existing database."
        </bad>
        <good>
          "Based on the user authentication specifications in /specs/features/user-auth/,
          generate the complete authentication implementation in /src/features/user-auth/"
        </good>
      </example>
    </practice>

    <practice name="context_layering">
      <description>Organize context in logical layers for systematic AI consumption</description>
      <technique>
        Structure specifications so AI can consume context systematically:
        system foundation, shared patterns, feature specifics, implementation details.
      </technique>
      <implementation>
        <layer>System Overview - establishes complete system context</layer>
        <layer>Shared Specifications - defines cross-cutting patterns</layer>
        <layer>Feature Specifications - provides feature-specific requirements</layer>
        <layer>Implementation Context - includes existing code patterns</layer>
      </implementation>
    </practice>

    <practice name="assumption_documentation">
      <description>Require AI to document assumptions and decisions</description>
      <technique>
        When AI must make implementation decisions, require explicit documentation
        of assumptions, rationale, and alternatives considered.
      </technique>
      <template>
        Request AI to include:
        - Assumptions Made: [List with rationale]
        - Specification References Used: [How they influenced implementation]
        - Validation Checklist: [Compliance with requirements]
      </template>
    </practice>

    <practice name="iterative_refinement">
      <description>Use systematic refinement when outputs don't meet standards</description>
      <technique>
        When AI outputs need improvement, provide specific feedback referencing
        specifications rather than general criticism.
      </technique>
      <template>
        - Issue Identification: [Specific problems with specification references]
        - Refinement Request: [Precise changes needed]
        - Validation Criteria: [How to verify the fix]
      </template>
    </practice>
  </context_engineering_practices>

  <team_collaboration_guidelines>
    <guideline name="specification_ownership">
      <rule>Assign clear ownership for each specification</rule>
      <rationale>Someone must be responsible for keeping specifications current</rationale>
      <implementation>
        <practice>Assign specification owners for each area</practice>
        <practice>Require owner approval for specification changes</practice>
        <practice>Include specification updates in definition of done</practice>
        <practice>Review specification currency regularly</practice>
      </implementation>
    </guideline>

    <guideline name="change_management">
      <rule>Treat specification changes as formal change management</rule>
      <rationale>Specification changes affect multiple team members and implementations</rationale>
      <implementation>
        <practice>Document impact of specification changes</practice>
        <practice>Communicate changes to affected team members</practice>
        <practice>Update dependent specifications and implementations</practice>
        <practice>Validate changes don't break existing functionality</practice>
      </implementation>
    </guideline>

    <guideline name="knowledge_sharing">
      <rule>Use specifications as primary knowledge sharing medium</rule>
      <rationale>Specifications provide comprehensive, current system knowledge</rationale>
      <implementation>
        <practice>Onboard new team members through specifications</practice>
        <practice>Reference specifications in code reviews</practice>
        <practice>Use specifications for technical discussions</practice>
        <practice>Keep specifications accessible to all team members</practice>
      </implementation>
    </guideline>
  </team_collaboration_guidelines>

  <common_pitfalls_and_solutions>
    <pitfall name="over_specification">
      <description>Creating overly detailed specifications that become maintenance burdens</description>
      <warning_signs>
        <sign>Specifications are longer than the code they describe</sign>
        <sign>Team avoids updating specifications due to complexity</sign>
        <sign>Specifications contain implementation details that change frequently</sign>
      </warning_signs>
      <solution>
        <approach>Focus on stable concepts and interfaces</approach>
        <approach>Separate volatile implementation details</approach>
        <approach>Use examples instead of exhaustive descriptions</approach>
        <approach>Reference existing patterns rather than redefining</approach>
      </solution>
    </pitfall>

    <pitfall name="specification_drift">
      <description>Specifications becoming outdated as implementation evolves</description>
      <warning_signs>
        <sign>Code doesn't match specification requirements</sign>
        <sign>Team refers to code instead of specifications</sign>
        <sign>New features ignore existing specifications</sign>
      </warning_signs>
      <solution>
        <approach>Include specification updates in all change processes</approach>
        <approach>Validate implementations against specifications regularly</approach>
        <approach>Make specification currency a quality gate</approach>
        <approach>Automate specification compliance checking where possible</approach>
      </solution>
    </pitfall>

    <pitfall name="context_fragmentation">
      <description>Context spread across multiple sources, making AI consumption difficult</description>
      <warning_signs>
        <sign>AI frequently asks for clarification</sign>
        <sign>Generated code doesn't integrate well</sign>
        <sign>Inconsistent patterns across implementations</sign>
      </warning_signs>
      <solution>
        <approach>Consolidate related context in single specifications</approach>
        <approach>Use clear reference patterns between specifications</approach>
        <approach>Test specifications by using them for AI generation</approach>
        <approach>Refine specifications based on AI interaction patterns</approach>
      </solution>
    </pitfall>

    <pitfall name="quality_assumption">
      <description>Assuming AI outputs are production-ready without systematic validation</description>
      <warning_signs>
        <sign>Production issues from AI-generated code</sign>
        <sign>Inconsistent quality across implementations</sign>
        <sign>Integration problems between components</sign>
      </warning_signs>
      <solution>
        <approach>Implement systematic validation processes</approach>
        <approach>Create comprehensive quality checklists</approach>
        <approach>Validate against specifications, not just functionality</approach>
        <approach>Include quality assurance in all workflows</approach>
      </solution>
    </pitfall>
  </common_pitfalls_and_solutions>

  <success_metrics>
    <metric name="specification_currency">
      <description>Percentage of specifications that are current and accurate</description>
      <target>95% or higher</target>
      <measurement>Regular audits comparing specifications to implementations</measurement>
    </metric>

    <metric name="first_pass_success">
      <description>Percentage of AI-generated implementations that meet requirements initially</description>
      <target>80% or higher</target>
      <measurement>Track implementations requiring refinement</measurement>
    </metric>

    <metric name="context_efficiency">
      <description>Reduction in human-AI interactions per feature</description>
      <target>50% reduction compared to traditional prompting</target>
      <measurement>Count interactions required per implementation</measurement>
    </metric>

    <metric name="team_velocity">
      <description>Increase in feature delivery speed</description>
      <target>30% improvement over traditional development</target>
      <measurement>Track time from specification to production deployment</measurement>
    </metric>
  </success_metrics>

  <continuous_improvement_practices>
    <practice>Regularly review and refine specification templates</practice>
    <practice>Collect feedback on context engineering effectiveness</practice>
    <practice>Update best practices based on project experience</practice>
    <practice>Share successful patterns across teams</practice>
    <practice>Measure and optimize specification-to-implementation workflows</practice>
  </continuous_improvement_practices>
</specification_first_best_practices>