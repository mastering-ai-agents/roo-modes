<specification_first_examples>
  <overview>
    Complete workflow examples demonstrating specification-first development
    and context engineering in practice, from initial planning to final validation.
  </overview>

  <example name="e_commerce_user_authentication">
    <description>Complete example of building user authentication for an e-commerce platform</description>
    <complexity>Medium</complexity>
    <duration>2-3 days</duration>

    <phase name="system_planning">
      <description>Establish system foundation and shared specifications</description>
      
      <step number="1">
        <action>Create System Overview Specification</action>
        <context_engineering_note>This provides the foundational context for all future AI interactions</context_engineering_note>
        <outcome>Complete system understanding documented in /specs/system-overview.md</outcome>
      </step>

      <step number="2">
        <action>Create Shared API Contract Specification</action>
        <context_engineering_note>Establishes global patterns that all features will reference</context_engineering_note>
        <outcome>Global API standards documented in /specs/shared/api-contract.md</outcome>
      </step>

      <step number="3">
        <action>Create Shared Data Model Specification</action>
        <context_engineering_note>Defines common data structures used across features</context_engineering_note>
        <outcome>Shared data models documented in /specs/shared/data-model.md</outcome>
      </step>
    </phase>

    <phase name="feature_specification">
      <description>Create comprehensive specifications for user authentication feature</description>
      
      <step number="1">
        <action>Create Feature Directory Structure</action>
        <tool_usage>
          <![CDATA[
<execute_command>
<command>mkdir -p specs/features/user-auth</command>
</execute_command>
          ]]>
        </tool_usage>
        <outcome>Feature directory created at /specs/features/user-auth/</outcome>
      </step>

      <step number="2">
        <action>Create Feature API Contract Specification</action>
        <context_engineering_approach>Reference shared API standards for consistency</context_engineering_approach>
        <specification_highlights>
          <highlight>Complete endpoint definitions with request/response formats</highlight>
          <highlight>Business logic documentation for each endpoint</highlight>
          <highlight>Error handling scenarios and responses</highlight>
          <highlight>Integration points with other system components</highlight>
        </specification_highlights>
        <outcome>Complete API contract documented in /specs/features/user-auth/api-contract.md</outcome>
      </step>

      <step number="3">
        <action>Create Feature Data Model Specification</action>
        <context_engineering_approach>Reference shared data patterns and extend for feature needs</context_engineering_approach>
        <specification_highlights>
          <highlight>Complete User model with all fields and validation rules</highlight>
          <highlight>Database indexes for optimal query performance</highlight>
          <highlight>Business rules for data integrity and security</highlight>
          <highlight>Relationships with other system entities</highlight>
        </specification_highlights>
        <outcome>Complete data model documented in /specs/features/user-auth/data-model.md</outcome>
      </step>

      <step number="4">
        <action>Create Feature UI Design Specification</action>
        <context_engineering_approach>Reference shared design system for consistency</context_engineering_approach>
        <specification_highlights>
          <highlight>Login and registration form designs with complete layouts</highlight>
          <highlight>Interactive behaviors and state management</highlight>
          <highlight>Accessibility requirements and keyboard navigation</highlight>
          <highlight>Error handling and validation display patterns</highlight>
        </specification_highlights>
        <outcome>Complete UI design documented in /specs/features/user-auth/ui-design.md</outcome>
      </step>

      <step number="5">
        <action>Create Feature Business Logic Specification</action>
        <context_engineering_approach>Reference shared business logic patterns</context_engineering_approach>
        <specification_highlights>
          <highlight>Complete authentication workflows with step-by-step processes</highlight>
          <highlight>Security measures including password hashing and rate limiting</highlight>
          <highlight>Error handling for all failure scenarios</highlight>
          <highlight>Integration patterns with external services</highlight>
        </specification_highlights>
        <outcome>Complete business logic documented in /specs/features/user-auth/business-logic.md</outcome>
      </step>
    </phase>

    <phase name="context_engineering_implementation">
      <description>Use context engineering principles for AI-assisted implementation</description>
      
      <step number="1">
        <action>Prepare Context References</action>
        <tool_usage>
          <![CDATA[
<read_file>
<args>
  <file>
    <path>specs/system-overview.md</path>
  </file>
  <file>
    <path>specs/shared/api-contract.md</path>
  </file>
  <file>
    <path>specs/features/user-auth/api-contract.md</path>
  </file>
  <file>
    <path>specs/features/user-auth/data-model.md</path>
  </file>
  <file>
    <path>specs/features/user-auth/business-logic.md</path>
  </file>
</args>
</read_file>
          ]]>
        </tool_usage>
        <context_engineering_note>Reading all relevant specifications provides complete context for implementation</context_engineering_note>
        <outcome>Complete context gathered from all relevant specifications</outcome>
      </step>

      <step number="2">
        <action>Generate Backend Implementation</action>
        <context_engineering_communication>
          <![CDATA[
Based on the specifications:
- System context: /specs/system-overview.md
- Global API standards: /specs/shared/api-contract.md
- Feature API contract: /specs/features/user-auth/api-contract.md
- Data models: /specs/features/user-auth/data-model.md
- Business logic: /specs/features/user-auth/business-logic.md

Generate the complete user authentication backend implementation into /src/features/user-auth/ including:
1. Express.js API endpoints per API specification
2. Data models and database schema per data specification
3. Business logic services per logic specification
4. Comprehensive error handling and validation
5. JWT token management with refresh rotation
6. Security measures including rate limiting and password hashing

Quality requirements:
- Follow all patterns from /specs/shared/api-contract.md
- Implement all business rules from business logic specification
- Include comprehensive error handling as specified
- Meet security requirements from system overview
- Use TypeScript for type safety
          ]]>
        </context_engineering_communication>
        <expected_ai_response>
          <![CDATA[
## Implementation
[Generated backend code following all specifications]

## Assumptions Made
- Using Express.js framework as specified in system overview
- PostgreSQL database connection configured as per system architecture
- JWT secret key available in environment variables
- Rate limiting middleware available from shared utilities

## Specification References Used
- /specs/system-overview.md: Technology stack and security requirements
- /specs/shared/api-contract.md: Response formats and error handling
- /specs/features/user-auth/api-contract.md: Endpoint definitions and contracts
- /specs/features/user-auth/data-model.md: User model structure and validation
- /specs/features/user-auth/business-logic.md: Authentication workflows and rules

## Validation Checklist
- [x] Follows global API standards from shared specification
- [x] Implements all business rules from feature specification
- [x] Uses specified data models and validation rules
- [x] Includes proper error handling and security measures
          ]]>
        </expected_ai_response>
        <outcome>Complete backend implementation generated following all specifications</outcome>
      </step>

      <step number="3">
        <action>Generate Frontend Implementation</action>
        <context_engineering_communication>
          <![CDATA[
Based on the specifications:
- System context: /specs/system-overview.md
- Design system: /specs/shared/ui-design.md
- UI design: /specs/features/user-auth/ui-design.md
- API contract: /specs/features/user-auth/api-contract.md

Generate the complete user authentication frontend implementation into /src/features/user-auth/components/ including:
1. React components per UI design specification
2. Form validation and error handling
3. API integration per API contract specification
4. State management for authentication flow
5. Accessibility features as specified

Quality requirements:
- Use React 18 with TypeScript as specified in system overview
- Follow design system patterns from shared UI specification
- Implement all interactive behaviors from UI specification
- Include comprehensive accessibility features
- Handle all error scenarios as specified
          ]]>
        </context_engineering_communication>
        <outcome>Complete frontend implementation generated following all specifications</outcome>
      </step>
    </phase>

    <phase name="quality_assurance">
      <description>Systematic validation and quality assurance</description>
      
      <step number="1">
        <action>Specification Compliance Review</action>
        <validation_process>
          <check>Verify all API endpoints match contract specification</check>
          <check>Confirm data models implement all specified fields and validation</check>
          <check>Validate UI components match design specifications</check>
          <check>Ensure business logic implements all specified rules</check>
          <check>Check error handling covers all specified scenarios</check>
        </validation_process>
        <tool_usage>
          <![CDATA[
<read_file>
<args>
  <file>
    <path>specs/features/user-auth/api-contract.md</path>
    <line_range>1-50</line_range>
  </file>
</args>
</read_file>

# Compare implementation against specification requirements
# Verify each endpoint, data model, and business rule is correctly implemented
          ]]>
        </tool_usage>
        <outcome>Implementation validated against all specification requirements</outcome>
      </step>

      <step number="2">
        <action>Integration Testing</action>
        <tool_usage>
          <![CDATA[
<execute_command>
<command>npm test -- --testPathPattern=user-auth --coverage</command>
</execute_command>
          ]]>
        </tool_usage>
        <validation_focus>
          <focus>API endpoint functionality and error handling</focus>
          <focus>Database operations and data validation</focus>
          <focus>Authentication flow and token management</focus>
          <focus>UI component behavior and accessibility</focus>
        </validation_focus>
        <outcome>All tests pass with comprehensive coverage</outcome>
      </step>

      <step number="3">
        <action>UI Validation</action>
        <tool_usage>
          <![CDATA[
<browser_navigate>
<url>http://localhost:3000/register</url>
</browser_navigate>

<browser_snapshot />

# Validate registration form matches UI specification
# Test interactive behaviors and error handling
# Verify accessibility features work correctly
          ]]>
        </tool_usage>
        <validation_checklist>
          <item>Visual design matches specification (colors, typography, spacing)</item>
          <item>Form validation works as specified</item>
          <item>Error messages display correctly</item>
          <item>Loading states appear during API calls</item>
          <item>Keyboard navigation works properly</item>
          <item>Screen reader compatibility verified</item>
        </validation_checklist>
        <outcome>UI implementation validated against design specifications</outcome>
      </step>

      <step number="4">
        <action>Security Validation</action>
        <security_checks>
          <check>Password hashing uses bcrypt with proper salt rounds</check>
          <check>JWT tokens have appropriate expiration times</check>
          <check>Rate limiting prevents brute force attacks</check>
          <check>Input validation prevents injection attacks</check>
          <check>Error messages don't leak sensitive information</check>
        </security_checks>
        <outcome>Security requirements validated and confirmed</outcome>
      </step>
    </phase>

    <lessons_learned>
      <lesson name="specification_completeness">
        <description>Complete specifications eliminate implementation ambiguity</description>
        <evidence>AI generated production-ready code without clarification requests</evidence>
        <impact>Reduced development time by 40% compared to traditional approach</impact>
      </lesson>
      
      <lesson name="context_engineering_effectiveness">
        <description>Reference-heavy communication dramatically improves AI output quality</description>
        <evidence>First-pass implementation met 95% of requirements</evidence>
        <impact>Minimal refinement needed, faster iteration cycles</impact>
      </lesson>
      
      <lesson name="systematic_validation">
        <description>Specification-based validation catches issues early</description>
        <evidence>All integration issues identified before deployment</evidence>
        <impact>Zero production bugs related to specification compliance</impact>
      </lesson>
    </lessons_learned>
  </example>

  <example name="api_endpoint_addition">
    <description>Adding a new API endpoint to existing specification-first project</description>
    <complexity>Low</complexity>
    <duration>2-4 hours</duration>

    <scenario>
      <description>Add user profile update endpoint to existing user authentication feature</description>
      <context>Existing user authentication system with complete specifications</context>
      <requirement>Allow users to update their profile information (name, email)</requirement>
    </scenario>

    <workflow>
      <step number="1">
        <action>Read Existing Specifications</action>
        <tool_usage>
          <![CDATA[
<read_file>
<args>
  <file>
    <path>specs/features/user-auth/api-contract.md</path>
  </file>
  <file>
    <path>specs/features/user-auth/data-model.md</path>
  </file>
  <file>
    <path>specs/features/user-auth/business-logic.md</path>
  </file>
</args>
</read_file>
          ]]>
        </tool_usage>
        <context_engineering_note>Gather complete context before making any changes</context_engineering_note>
        <outcome>Understanding of existing patterns and integration points</outcome>
      </step>

      <step number="2">
        <action>Update API Contract Specification</action>
        <specification_addition>
          <![CDATA[
### Update User Profile
- **Method**: PUT
- **Path**: /auth/profile
- **Purpose**: Update user profile information
- **Authentication**: Required (JWT Bearer token)

#### Request
```json
{
  "firstName": "John",
  "lastName": "Doe",
  "email": "newemail@example.com"
}
```

#### Response (Success - 200)
```json
{
  "data": {
    "user": {
      "id": "user_123",
      "email": "newemail@example.com",
      "firstName": "John",
      "lastName": "Doe",
      "updatedAt": "2024-01-15T10:30:00Z"
    }
  }
}
```

#### Business Logic
- Email must be unique if changed
- All fields are optional (partial updates allowed)
- User must be authenticated to update their own profile
- Email change requires re-verification (future enhancement)
          ]]>
        </specification_addition>
        <outcome>API contract updated with new endpoint specification</outcome>
      </step>

      <step number="3">
        <action>Update Business Logic Specification</action>
        <specification_addition>
          <![CDATA[
### Profile Update Workflow
**Purpose**: Allow authenticated users to update their profile information
**Trigger**: PUT request to /auth/profile

#### Workflow Steps
1. **Authentication Validation**: Verify JWT token and extract user ID
2. **Input Validation**: Validate provided fields (optional fields)
3. **Email Uniqueness Check**: If email changed, verify it's not taken
4. **Profile Update**: Update user record with new information
5. **Response**: Return updated user profile data

#### Business Rules
- **Partial Updates**: Users can update any combination of fields
- **Email Uniqueness**: New email must not be used by another user
- **Self-Service Only**: Users can only update their own profile
- **Audit Trail**: Track profile changes with timestamps
          ]]>
        </specification_addition>
        <outcome>Business logic updated with profile update workflow</outcome>
      </step>

      <step number="4">
        <action>Generate Implementation</action>
        <context_engineering_communication>
          <![CDATA[
Based on the updated specifications:
- Existing API patterns: /specs/features/user-auth/api-contract.md
- Data model: /specs/features/user-auth/data-model.md
- Updated business logic: /specs/features/user-auth/business-logic.md

Add the profile update endpoint to the existing user authentication implementation:
1. Add PUT /auth/profile endpoint following existing patterns
2. Implement profile update business logic as specified
3. Include proper validation and error handling
4. Maintain consistency with existing authentication endpoints

Quality requirements:
- Follow existing code patterns and structure
- Use same validation and error handling approaches
- Maintain security standards from existing implementation
- Include appropriate tests for the new functionality
          ]]>
        </context_engineering_communication>
        <outcome>New endpoint implemented following existing patterns</outcome>
      </step>

      <step number="5">
        <action>Validate Implementation</action>
        <validation_steps>
          <step>Test endpoint functionality with various input scenarios</step>
          <step>Verify error handling for validation failures</step>
          <step>Confirm security measures prevent unauthorized access</step>
          <step>Check integration with existing authentication flow</step>
        </validation_steps>
        <tool_usage>
          <![CDATA[
<execute_command>
<command>npm test -- --testPathPattern=profile-update</command>
</execute_command>
          ]]>
        </tool_usage>
        <outcome>Implementation validated and ready for deployment</outcome>
      </step>
    </workflow>

    <key_benefits>
      <benefit>Specification-first approach made addition seamless</benefit>
      <benefit>Existing patterns ensured consistency</benefit>
      <benefit>Context engineering eliminated ambiguity</benefit>
      <benefit>Systematic validation caught edge cases</benefit>
    </key_benefits>
  </example>

  <example name="legacy_system_migration">
    <description>Converting existing code to specification-first approach</description>
    <complexity>High</complexity>
    <duration>1-2 weeks</duration>

    <scenario>
      <description>Migrate existing shopping cart feature to specification-first development</description>
      <context>Legacy shopping cart with mixed patterns and incomplete documentation</context>
      <goal>Create comprehensive specifications and refactor for maintainability</goal>
    </scenario>

    <migration_workflow>
      <phase name="analysis_and_extraction">
        <step number="1">
          <action>Analyze Existing Implementation</action>
          <tool_usage>
            <![CDATA[
<list_files>
<path>src/cart</path>
<recursive>true</recursive>
</list_files>

<search_files>
<path>src/cart</path>
<regex>export.*function|class.*{|interface.*{</regex>
<file_pattern>*.ts</file_pattern>
</search_files>
            ]]>
          </tool_usage>
          <analysis_focus>
            <focus>Identify all API endpoints and their behavior</focus>
            <focus>Map data models and database interactions</focus>
            <focus>Document business logic and validation rules</focus>
            <focus>Catalog UI components and their interactions</focus>
          </analysis_focus>
          <outcome>Complete understanding of existing implementation</outcome>
        </step>

        <step number="2">
          <action>Extract Business Requirements</action>
          <extraction_process>
            <process>Review existing code to understand business logic</process>
            <process>Identify implicit requirements from implementation</process>
            <process>Document current user workflows and behaviors</process>
            <process>Catalog integration points with other features</process>
          </extraction_process>
          <outcome>Business requirements extracted from existing code</outcome>
        </step>
      </phase>

      <phase name="specification_creation">
        <step number="1">
          <action>Create API Contract Specification</action>
          <approach>Document all existing endpoints with their current behavior</approach>
          <improvements>
            <improvement>Standardize response formats</improvement>
            <improvement>Improve error handling consistency</improvement>
            <improvement>Add missing validation rules</improvement>
            <improvement>Document business logic for each endpoint</improvement>
          </improvements>
          <outcome>Complete API contract specification created</outcome>
        </step>

        <step number="2">
          <action>Create Data Model Specification</action>
          <approach>Document existing data structures and relationships</approach>
          <improvements>
            <improvement>Add missing validation rules</improvement>
            <improvement>Optimize database indexes</improvement>
            <improvement>Standardize field naming conventions</improvement>
            <improvement>Add audit fields for tracking changes</improvement>
          </improvements>
          <outcome>Complete data model specification created</outcome>
        </step>

        <step number="3">
          <action>Create UI Design Specification</action>
          <approach>Document existing UI components and behaviors</approach>
          <improvements>
            <improvement>Standardize component interfaces</improvement>
            <improvement>Improve accessibility features</improvement>
            <improvement>Add missing error states</improvement>
            <improvement>Enhance responsive design</improvement>
          </improvements>
          <outcome>Complete UI design specification created</outcome>
        </step>

        <step number="4">
          <action>Create Business Logic Specification</action>
          <approach>Document existing business rules and workflows</approach>
          <improvements>
            <improvement>Clarify ambiguous business rules</improvement>
            <improvement>Add missing edge case handling</improvement>
            <improvement>Improve error handling strategies</improvement>
            <improvement>Document integration patterns</improvement>
          </improvements>
          <outcome>Complete business logic specification created</outcome>
        </step>
      </phase>

      <phase name="systematic_refactoring">
        <step number="1">
          <action>Refactor Backend Implementation</action>
          <context_engineering_approach>
            <![CDATA[
Based on the extracted specifications:
- API contract: /specs/features/shopping-cart/api-contract.md
- Data model: /specs/features/shopping-cart/data-model.md
- Business logic: /specs/features/shopping-cart/business-logic.md
- System patterns: /specs/shared/

Refactor the existing shopping cart backend implementation to follow the specifications:
1. Update API endpoints to match contract specification
2. Refactor data models to follow specification standards
3. Implement business logic as specified
4. Add comprehensive error handling and validation
5. Maintain backward compatibility where possible

Quality requirements:
- Follow all shared patterns and standards
- Improve code organization and maintainability
- Add comprehensive test coverage
- Include proper documentation and comments
            ]]>
          </context_engineering_approach>
          <outcome>Backend refactored to specification standards</outcome>
        </step>

        <step number="2">
          <action>Refactor Frontend Implementation</action>
          <context_engineering_approach>
            <![CDATA[
Based on the specifications:
- UI design: /specs/features/shopping-cart/ui-design.md
- API contract: /specs/features/shopping-cart/api-contract.md
- Design system: /specs/shared/ui-design.md

Refactor the existing shopping cart frontend implementation:
1. Update components to match UI design specification
2. Improve accessibility and responsive design
3. Standardize error handling and loading states
4. Enhance user experience based on specifications
5. Maintain existing functionality while improving quality

Quality requirements:
- Follow design system standards
- Improve accessibility compliance
- Add comprehensive error handling
- Include proper TypeScript types
            ]]>
          </context_engineering_approach>
          <outcome>Frontend refactored to specification standards</outcome>
        </step>
      </phase>

      <phase name="validation_and_deployment">
        <step number="1">
          <action>Comprehensive Testing</action>
          <testing_strategy>
            <strategy>Unit tests for all business logic</strategy>
            <strategy>Integration tests for API endpoints</strategy>
            <strategy>UI tests for component behavior</strategy>
            <strategy>End-to-end tests for complete workflows</strategy>
          </testing_strategy>
          <outcome>All tests pass with high coverage</outcome>
        </step>

        <step number="2">
          <action>Performance Validation</action>
          <performance_checks>
            <check>API response times meet specification requirements</check>
            <check>Database queries are optimized</check>
            <check>Frontend rendering performance is acceptable</check>
            <check>Memory usage is within acceptable limits</check>
          </performance_checks>
          <outcome>Performance meets or exceeds original implementation</outcome>
        </step>

        <step number="3">
          <action>Gradual Deployment</action>
          <deployment_strategy>
            <strategy>Feature flag controlled rollout</strategy>
            <strategy>A/B testing with small user percentage</strategy>
            <strategy>Monitor key metrics and error rates</strategy>
            <strategy>Gradual increase in traffic percentage</strategy>
          </deployment_strategy>
          <outcome>Successful migration with no user impact</outcome>
        </step>
      </phase>
    </migration_workflow>

    <migration_benefits>
      <benefit name="maintainability">
        <description>Code is now organized and documented according to specifications</description>
        <measurement>Developer onboarding time reduced by 60%</measurement>
      </benefit>
      
      <benefit name="reliability">
        <description>Comprehensive specifications caught edge cases and improved error handling</description>
        <measurement>Bug reports reduced by 45% after migration</measurement>
      </benefit>
      
      <benefit name="development_velocity">
        <description>Clear specifications enable faster feature development</description>
        <measurement>New feature development 35% faster</measurement>
      </benefit>
      
      <benefit name="team_collaboration">
        <description>Specifications provide clear communication medium for team</description>
        <measurement>Cross-team integration issues reduced by 70%</measurement>
      </benefit>
    </migration_benefits>
  </example>

  <success_patterns>
    <pattern name="specification_completeness">
      <description>Complete specifications eliminate ambiguity and reduce clarification needs</description>
      <indicators>
        <indicator>AI generates code without asking clarification questions</indicator>
        <indicator>Implementation matches requirements on first attempt</indicator>
        <indicator>Team members understand requirements without additional explanation</indicator>
      </indicators>
    </pattern>

    <pattern name="context_engineering_effectiveness">
      <description>Reference-heavy communication dramatically improves AI output quality</description>
      <indicators>
        <indicator>AI responses include proper assumption documentation</indicator>
        <indicator>Generated code follows established patterns consistently</indicator>
        <indicator>Integration points work correctly without additional guidance</indicator>
      </indicators>
    </pattern>

    <pattern name="systematic_validation">
      <description>Specification-based validation catches issues early and ensures quality</description>
      <indicators>
        <indicator>Implementation passes all specification compliance checks</indicator>
        <indicator>Integration tests validate all specified behaviors</indicator>
        <indicator>UI validation confirms design specification adherence</indicator>
      </indicators>
    </pattern>
  </success_patterns>

  <common_challenges_and_solutions>
    <challenge name="specification_maintenance">
      <description>Keeping specifications current as requirements evolve</description>
      <solution>
        <approach>Update specifications before making any code changes</approach>
        <approach>Include specification updates in all feature development workflows</approach>
        <approach>Regular specification review and cleanup cycles</approach>
        <approach>Automated validation to catch specification drift</approach>
      </solution>
    </challenge>

    <challenge name="team_adoption">
      <description>Getting team members to consistently follow specification-first approach</description>
      <solution>
        <approach>Provide comprehensive training on specification-first development</approach>
        <approach>Create templates and tools to make specification creation easier</approach>
        <approach>Implement code review processes that check specification compliance</approach>
        <approach>Demonstrate value through successful project examples</approach>
      </solution>
    </challenge>

    <challenge name="legacy_integration">
      <description>Integrating specification-first features with legacy systems</description>
      <solution>
        <approach>Create adapter specifications for legacy system interfaces</approach>
        <approach>Gradually migrate legacy components using systematic approach</approach>
        <approach>Document legacy system behaviors in specification format</approach>
        <approach>Use feature flags to enable gradual migration</approach>
      </solution>
    </challenge>
  </common_challenges_and_solutions>
</specification_first_examples>